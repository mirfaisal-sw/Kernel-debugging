=================================================================
***********************Dynamic Debugging*************************

=================================================================

=>  Using Dynamic Debugging facility in linux kernel, we can enable or 
    disable kernel debug code at runtime to obtain debug log.
 
=>  Kernel APIs used for this be:-
    ->pr_debug(), dev_dbg()
	
    ->print_hex_dump_debug(), print_hex_dump_debug_bytes
	
=>  Normally debugging using printk() etc are enabled using defining or 
    undefining a macro which needs to rebuild the kernel. So it is not 
    good or convenient for debugging.
    Linux has very clever feature called dynamic debugging.
    If the CONFIG_DYNAMIC_DEBUG option is not set, the above function will turn into
    a normal printk() statement at the KERN_DEBUG level.
   
    If the option is enabled, the code set aside a special descriptor for every call site, 
    noting the module, function, and file names along with the line number and format string.
   
    Turning on dynamic debug causes a new virtual file to appear at /sys/kernel/debug/dynamic_debug/control.
   
=>  Benefits of dynamic debugging:-
	-> Almost no overhead when log code is not enabled
	-> Turn On/Off debug log at runtime.
	-> No need to recompile the kernel.
	
=>  There are two ways for dynamic debugging:-
		1. Using debugfs
		2. Using u-boot bootargs
		
		1. Using debugfs:-
		   ---------------
		   
		   Syntax: echo "<matches> <ops> <flags>" > <debugfs>/dynamic_debug/control
		   
		   <matches> has following choices:-
		   - 'file' string
		   - 'func' string
		   - 'line' line-range
		   - 'module' string (as seen in lsmod)
		   - it supports wild card as well(*, ?)
		   
		   <ops> has following choices:-
		   -   -> remove the given flags
		   +   -> add the given flags
		   =   -> set to the given flags and override any flags set before
		   
		   <flags> has following choices:-
		   p   -> prints the log message
		   f   -> include the function name
		   l   -> include the line number
		   m   -> include the module name
		   t   -> include the Thread ID
		   _(underscore)  -> no flags are set
		   
		   Note :- flags can be combined together.
		   For exapmple:- 'pfl' means print the log message including function name and line no.
		   We can even clear all flags with '-pflmt', details we will see later in thid file.
		   
		   
		   => Procedure to use debugfs:-
		    I.Mount debugfs if file system doesen't do it automatically.
			 #mount -t debugfs none /sys/kernel/debug/
			
			II. #cd /sys/kernel/debug/dynamic_debug/
			
			III. Now based on the requirement we can enable or disable debug prints at run time
			using diffrent flags and options as below.
			
			a. Turn on all debug logs in a file:-
			#echo "file xyz.c +p" > control
			
			b. Turn on log in a particular line number in a file:-
			#echo "file abcd.c line 1603 +p" > control
			
			c. Turn on all debug logs under all files in usb/core/folder:-
			#echo "file drivers/usb/core/* +p" > control
			
			d.Turn off all the logs in a file;-
			#echo "file abc123.c -p" > control
			
			e. Turn on debugging at line range:-
			echo "file pnp_dabplugin.c line 234-485 +p" > .../control
		   
		   
		2. Using u-boot bootargs:-

		->This allows debugging of core code or built in modules during the boot process.
		
		-> uboot bootargs:-
			- dyndbg = "QUERY"      (for kernel)
			- module.dyndbg = "QUERY" (for modules)
			
			Example:-
			dyndbg = "file abc.c +p"
			
			
=> How to enable dynamic debugging in Linux kernel:-
	
	-> CONFIG_DYNAMIC_DEBUG=y
	
	-> make menuconfig:
	
		kernel hacking -->
			printk and dmesg optons -->
				[*] Enable dynamic printk() support
		   
=> Example of debugging USB xHCI:-

	-> Boot your board
		- dmesg -c
		
	-> echo "module xhci_hcd =p" > /sys/kernel/debug/dynamic_debug/control
	
	-> Plug a USN device into the USB host port
	
	->dmseg
	
	
=> How to add dynamic debug APIs in kernel code or our driver source code:-
  
   1) dev_dbg():-
   dev_dbg(struct device *dev, char *format, ...)
   
	Example: -
	static int dab_fill_kfifo(void *data)
	{
        
        struct dabspi_data *dabspi = data;
        
        res = is_valid_dabheader(dabspi->rx_buf);
        if (!res) {
                print_hex_dump_debug("PNP_Dabplugin: Invalid Packet: ",
                                        DUMP_PREFIX_OFFSET, 16, 1,
                                        dabspi->rx_buf, dabspi->txlen, false);
                goto ret;
        }

        dev_dbg(&dabspi->spi->dev,"PNP_Dabplugin: RXD Len = %d DAB PKT LEN = %d\n",
		
		/
		/
		/
	}
	
	Thus first argument of dev_dbg() api should point to "struct device"
	
	2) pr_debug():-
	Example:-
	pr_debug("id3 = %s\n",temp->name);
	
=>	To see dynamic debug state to a particular file etc, we do as below.
	
	#cat /sys/kernel/debug/dynamic_debug/control | grep pnp_dablugin
	O/p:-
	{If output comes like ........=_ ........... i.e if equal to underscore
	appears it means debug log print is disabled.
	
	But if output comes like .......=p .......i.e if equal to p appears then
	it means debug log is enabled.
	}
	
=> Use case:-
	#rmmod pnp_dablugin
	
	#cat /sys/kernel/debug/dynamic_debug/control | grep pnp_dablugin
	o/p - Nill
	
	#insmod pnp_dablugin
	
	#cat /sys/kernel/debug/dynamic_debug/control | grep pnp_dablugin
	o/p - {output with .......=_.........}
	
	#echo "module pnp_dablugin +p" > /sys/kernel/debug/dynamic_debug/control
	
	#cat /sys/kernel/debug/dynamic_debug/control | grep pnp_dablugin
	o/p - {output with .......=p........}
	
	Now if we test our driver then whereever in our code dev_dbg(), pr_debug()
	etc is used will print and will appear in dmesg output.
	
=> Kernel code implementation or code extracts:-
	a) dev_dbg() implementation in linux:-
	
	//Enable config_ DYNAMIC_ After debug, it will print dynamically according to the control information
	#if defined(CONFIG_DYNAMIC_DEBUG)
	#define dev_dbg(dev, format, ...)		     
	do {						     
		dynamic_dev_dbg(dev, format, ##__VA_ARGS__); 
	} while (0)
	
	//Enable DEBUG to print the dev of the whole kernel_ DBG information
	#elif defined(DEBUG)
	#define dev_dbg(dev, format, arg...)		
		dev_printk(KERN_DEBUG, dev, format, ##arg)
		//None of them, dev_dbg doesn't print anything
	#else
	#define dev_dbg(dev, format, arg...)				
	({								
		if (0)							
			dev_printk(KERN_DEBUG, dev, format, ##arg);	
		0;							
	})
	#endif
	
	The following dynamic_dev_dbg() implementation obviously shows that printing is based
	on the descriptor's flag bit_ DPRINTK_FLAGS_PRINT is used to print, and the flag bit 
	can be controlled by dbgfs.

	#define dynamic_dev_dbg(dev, fmt, ...)				
	do {								
		DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);		
		if (unlikely(descriptor.flags & _DPRINTK_FLAGS_PRINT))	
			__dynamic_dev_dbg(&descriptor, dev, fmt,	
				  ##__VA_ARGS__);		
	} while (0)
	
	
	b) print_hex_dump_debug():-
	file - include/linux/prink.h
	
	#if defined(CONFIG_DYNAMIC_DEBUG) || \
	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
	#define print_hex_dump_debug(prefix_str, prefix_type, rowsize,	\
			     groupsize, buf, len, ascii)	\
		dynamic_hex_dump(prefix_str, prefix_type, rowsize,	\
			 groupsize, buf, len, ascii)
	#elif defined(DEBUG)
	#define print_hex_dump_debug(prefix_str, prefix_type, rowsize,		\
			     groupsize, buf, len, ascii)		\
	print_hex_dump(KERN_DEBUG, prefix_str, prefix_type, rowsize,	\
		       groupsize, buf, len, ascii)
	#else
	static inline void print_hex_dump_debug(const char *prefix_str, int prefix_type,
					int rowsize, int groupsize,
					const void *buf, size_t len, bool ascii)
	{
	}
	#endif
	
	/**
	* print_hex_dump_bytes - shorthand form of print_hex_dump() with default params
	* @prefix_str: string to prefix each line with;
	*  caller supplies trailing spaces for alignment if desired
	* @prefix_type: controls whether prefix of an offset, address, or none
	*  is printed (%DUMP_PREFIX_OFFSET, %DUMP_PREFIX_ADDRESS, %DUMP_PREFIX_NONE)
	* @buf: data blob to dump
	* @len: number of bytes in the @buf
	*	
	* Calls print_hex_dump(), with log level of KERN_DEBUG,
	* rowsize of 16, groupsize of 1, and ASCII output included.
	*/
	#define print_hex_dump_bytes(prefix_str, prefix_type, buf, len)	\
		print_hex_dump_debug(prefix_str, prefix_type, 16, 1, buf, len, true)
	#endif
  
  Note:-
  If we want to enable dynamic debug to a module say pnp_dabplugin.ko, which is present in path
  /lib/modules/4.414/kernel/drivers/harman/pnp_plugin/ in target. But its source file was present
  in path "drivers/harman/pnp_plugin/pnp_dabplugin.c".
  So, we will use below method to enable dynamic debugging.
  
  $cd /sys/kernel/debug/dynamic_debug/
  $echo "file drivers/harman/pnp_plugin/pnp_dabplugin.c +p" > control
  
  Note/Observation:-
  ==================
  1)	It is found that if CONFIG_DYNAMIC_DEBUG=y for dynamic debugging but CONFIG_DEBUG_INFO is not set
  	(required for production buid), even then dynamic debugging works.
  2)    dev_err() is not controllable as dev_dbg(). It is always enabled, only thing is its first argument
        is device.
